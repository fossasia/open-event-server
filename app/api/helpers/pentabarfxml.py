from pentabarf.Conference import Conference
from pentabarf.Day import Day
from pentabarf.Event import Event
from flask import url_for
from pentabarf.Person import Person
from pentabarf.Room import Room
from sqlalchemy import DATE
from sqlalchemy import asc
from sqlalchemy import cast
from sqlalchemy import func

from app import db
from app.models.session import Session
from app.settings import get_settings
from app.models.event import Event as EventModel
from app.models.microlocation import Microlocation


class PentabarfExporter:
    def __init__(self):
        pass

    @staticmethod
    def export(event_id):
        """Takes an event id and returns the event in pentabarf XML format"""
        event = EventModel.query.get(event_id)
        diff = (event.ends_at - event.starts_at)

        conference = Conference(title=event.name, start=event.starts_at, end=event.ends_at,
                                days=diff.days if diff.days > 0 else 1,
                                day_change="00:00", timeslot_duration="00:15",
                                venue=event.location_name)
        dates = (db.session.query(cast(Session.starts_at, DATE))
                 .filter_by(event_id=event_id)
                 .filter_by(state='accepted')
                 .filter(Session.deleted_at.is_(None))
                 .order_by(asc(Session.starts_at)).distinct().all())

        for date in dates:
            date = date[0]
            day = Day(date=date)
            microlocation_ids = list(db.session.query(Session.microlocation_id)
                                     .filter(func.date(Session.starts_at) == date)
                                     .filter_by(state='accepted')
                                     .filter(Session.deleted_at.is_(None))
                                     .order_by(asc(Session.microlocation_id)).distinct())

            for microlocation_tuple in microlocation_ids:
                microlocation_id = microlocation_tuple[0]
                if microlocation_id:
                    microlocation = Microlocation.query.get(microlocation_id)
                    sessions = Session.query.filter_by(microlocation_id=microlocation_id) \
                        .filter(func.date(Session.starts_at) == date) \
                        .filter_by(state='accepted') \
                        .filter(Session.deleted_at.is_(None)) \
                        .order_by(asc(Session.starts_at)).all()

                    room = Room(name=microlocation.name)
                    for session in sessions:

                        session_event = Event(id=session.id,
                                              date=session.starts_at,
                                              start=session.starts_at,
                                              duration=str(session.ends_at - session.starts_at) + "00:00",
                                              track=session.track.name,
                                              abstract=session.short_abstract,
                                              title=session.title,
                                              type='Talk',
                                              description=session.long_abstract,
                                              conf_url=url_for('v1.event_list',
                                                               identifier=event.identifier),
                                              full_conf_url=url_for('v1.event_list',
                                                                    identifier=event.identifier, _external=True),
                                              released="True" if event.schedule_published_on else "False")

                        for speaker in session.speakers:
                            person = Person(id=speaker.id, name=speaker.name)
                            session_event.add_person(person)

                        room.add_event(session_event)
                    day.add_room(room)
            conference.add_day(day)

        return conference.generate("Generated by " + get_settings()['app_name'])
